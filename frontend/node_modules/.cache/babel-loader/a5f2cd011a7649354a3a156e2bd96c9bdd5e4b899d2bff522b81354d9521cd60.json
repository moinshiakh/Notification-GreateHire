{"ast":null,"code":"/**\r\n * Expose `pathToRegexp`.\r\n */\n\nmodule.exports = pathToRegexp;\n\n/**\r\n * Match matching groups in a regular expression.\r\n */\nvar MATCHING_GROUP_REGEXP = /\\\\.|\\((?:\\?<(.*?)>)?(?!\\?)/g;\n\n/**\r\n * Normalize the given path string,\r\n * returning a regular expression.\r\n *\r\n * An empty array should be passed,\r\n * which will contain the placeholder\r\n * key names. For example \"/user/:id\" will\r\n * then contain [\"id\"].\r\n *\r\n * @param  {String|RegExp|Array} path\r\n * @param  {Array} keys\r\n * @param  {Object} options\r\n * @return {RegExp}\r\n * @api private\r\n */\n\nfunction pathToRegexp(path, keys, options) {\n  options = options || {};\n  keys = keys || [];\n  var strict = options.strict;\n  var end = options.end !== false;\n  var flags = options.sensitive ? '' : 'i';\n  var lookahead = options.lookahead !== false;\n  var extraOffset = 0;\n  var keysOffset = keys.length;\n  var i = 0;\n  var name = 0;\n  var pos = 0;\n  var backtrack = '';\n  var m;\n  if (path instanceof RegExp) {\n    while (m = MATCHING_GROUP_REGEXP.exec(path.source)) {\n      if (m[0][0] === '\\\\') continue;\n      keys.push({\n        name: m[1] || name++,\n        optional: false,\n        offset: m.index\n      });\n    }\n    return path;\n  }\n  if (Array.isArray(path)) {\n    // Map array parts into regexps and return their source. We also pass\n    // the same keys and options instance into every generation to get\n    // consistent matching groups before we join the sources together.\n    path = path.map(function (value) {\n      return pathToRegexp(value, keys, options).source;\n    });\n    return new RegExp(path.join('|'), flags);\n  }\n  if (typeof path !== 'string') {\n    throw new TypeError('path must be a string, array of strings, or regular expression');\n  }\n  path = path.replace(/\\\\.|(\\/)?(\\.)?:(\\w+)(\\(.*?\\))?(\\*)?(\\?)?|[.*]|\\/\\(/g, function (match, slash, format, key, capture, star, optional, offset) {\n    if (match[0] === '\\\\') {\n      backtrack += match;\n      pos += 2;\n      return match;\n    }\n    if (match === '.') {\n      backtrack += '\\\\.';\n      extraOffset += 1;\n      pos += 1;\n      return '\\\\.';\n    }\n    if (slash || format) {\n      backtrack = '';\n    } else {\n      backtrack += path.slice(pos, offset);\n    }\n    pos = offset + match.length;\n    if (match === '*') {\n      extraOffset += 3;\n      return '(.*)';\n    }\n    if (match === '/(') {\n      backtrack += '/';\n      extraOffset += 2;\n      return '/(?:';\n    }\n    slash = slash || '';\n    format = format ? '\\\\.' : '';\n    optional = optional || '';\n    capture = capture ? capture.replace(/\\\\.|\\*/, function (m) {\n      return m === '*' ? '(.*)' : m;\n    }) : backtrack ? '((?:(?!/|' + backtrack + ').)+?)' : '([^/' + format + ']+?)';\n    keys.push({\n      name: key,\n      optional: !!optional,\n      offset: offset + extraOffset\n    });\n    var result = '(?:' + format + slash + capture + (star ? '((?:[/' + format + '].+?)?)' : '') + ')' + optional;\n    extraOffset += result.length - match.length;\n    return result;\n  });\n\n  // This is a workaround for handling unnamed matching groups.\n  while (m = MATCHING_GROUP_REGEXP.exec(path)) {\n    if (m[0][0] === '\\\\') continue;\n    if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) {\n      keys.splice(keysOffset + i, 0, {\n        name: name++,\n        // Unnamed matching groups must be consistently linear.\n        optional: false,\n        offset: m.index\n      });\n    }\n    i++;\n  }\n  path += strict ? '' : path[path.length - 1] === '/' ? '?' : '/?';\n\n  // If the path is non-ending, match until the end or a slash.\n  if (end) {\n    path += '$';\n  } else if (path[path.length - 1] !== '/') {\n    path += lookahead ? '(?=/|$)' : '(?:/|$)';\n  }\n  return new RegExp('^' + path, flags);\n}\n;","map":{"version":3,"names":["module","exports","pathToRegexp","MATCHING_GROUP_REGEXP","path","keys","options","strict","end","flags","sensitive","lookahead","extraOffset","keysOffset","length","i","name","pos","backtrack","m","RegExp","exec","source","push","optional","offset","index","Array","isArray","map","value","join","TypeError","replace","match","slash","format","key","capture","star","slice","result","splice"],"sources":["C:/Users/RUPA/Desktop/Notification/Notification-GreateHire/frontend/node_modules/path-to-regexp/index.js"],"sourcesContent":["/**\r\n * Expose `pathToRegexp`.\r\n */\r\n\r\nmodule.exports = pathToRegexp;\r\n\r\n/**\r\n * Match matching groups in a regular expression.\r\n */\r\nvar MATCHING_GROUP_REGEXP = /\\\\.|\\((?:\\?<(.*?)>)?(?!\\?)/g;\r\n\r\n/**\r\n * Normalize the given path string,\r\n * returning a regular expression.\r\n *\r\n * An empty array should be passed,\r\n * which will contain the placeholder\r\n * key names. For example \"/user/:id\" will\r\n * then contain [\"id\"].\r\n *\r\n * @param  {String|RegExp|Array} path\r\n * @param  {Array} keys\r\n * @param  {Object} options\r\n * @return {RegExp}\r\n * @api private\r\n */\r\n\r\nfunction pathToRegexp(path, keys, options) {\r\n  options = options || {};\r\n  keys = keys || [];\r\n  var strict = options.strict;\r\n  var end = options.end !== false;\r\n  var flags = options.sensitive ? '' : 'i';\r\n  var lookahead = options.lookahead !== false;\r\n  var extraOffset = 0;\r\n  var keysOffset = keys.length;\r\n  var i = 0;\r\n  var name = 0;\r\n  var pos = 0;\r\n  var backtrack = '';\r\n  var m;\r\n\r\n  if (path instanceof RegExp) {\r\n    while (m = MATCHING_GROUP_REGEXP.exec(path.source)) {\r\n      if (m[0][0] === '\\\\') continue;\r\n\r\n      keys.push({\r\n        name: m[1] || name++,\r\n        optional: false,\r\n        offset: m.index\r\n      });\r\n    }\r\n\r\n    return path;\r\n  }\r\n\r\n  if (Array.isArray(path)) {\r\n    // Map array parts into regexps and return their source. We also pass\r\n    // the same keys and options instance into every generation to get\r\n    // consistent matching groups before we join the sources together.\r\n    path = path.map(function (value) {\r\n      return pathToRegexp(value, keys, options).source;\r\n    });\r\n\r\n    return new RegExp(path.join('|'), flags);\r\n  }\r\n\r\n  if (typeof path !== 'string') {\r\n    throw new TypeError('path must be a string, array of strings, or regular expression');\r\n  }\r\n\r\n  path = path.replace(\r\n    /\\\\.|(\\/)?(\\.)?:(\\w+)(\\(.*?\\))?(\\*)?(\\?)?|[.*]|\\/\\(/g,\r\n    function (match, slash, format, key, capture, star, optional, offset) {\r\n      if (match[0] === '\\\\') {\r\n        backtrack += match;\r\n        pos += 2;\r\n        return match;\r\n      }\r\n\r\n      if (match === '.') {\r\n        backtrack += '\\\\.';\r\n        extraOffset += 1;\r\n        pos += 1;\r\n        return '\\\\.';\r\n      }\r\n\r\n      if (slash || format) {\r\n        backtrack = '';\r\n      } else {\r\n        backtrack += path.slice(pos, offset);\r\n      }\r\n\r\n      pos = offset + match.length;\r\n\r\n      if (match === '*') {\r\n        extraOffset += 3;\r\n        return '(.*)';\r\n      }\r\n\r\n      if (match === '/(') {\r\n        backtrack += '/';\r\n        extraOffset += 2;\r\n        return '/(?:';\r\n      }\r\n\r\n      slash = slash || '';\r\n      format = format ? '\\\\.' : '';\r\n      optional = optional || '';\r\n      capture = capture ?\r\n        capture.replace(/\\\\.|\\*/, function (m) { return m === '*' ? '(.*)' : m; }) :\r\n        (backtrack ? '((?:(?!/|' + backtrack + ').)+?)' : '([^/' + format + ']+?)');\r\n\r\n      keys.push({\r\n        name: key,\r\n        optional: !!optional,\r\n        offset: offset + extraOffset\r\n      });\r\n\r\n      var result = '(?:'\r\n        + format + slash + capture\r\n        + (star ? '((?:[/' + format + '].+?)?)' : '')\r\n        + ')'\r\n        + optional;\r\n\r\n      extraOffset += result.length - match.length;\r\n\r\n      return result;\r\n    });\r\n\r\n  // This is a workaround for handling unnamed matching groups.\r\n  while (m = MATCHING_GROUP_REGEXP.exec(path)) {\r\n    if (m[0][0] === '\\\\') continue;\r\n\r\n    if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) {\r\n      keys.splice(keysOffset + i, 0, {\r\n        name: name++, // Unnamed matching groups must be consistently linear.\r\n        optional: false,\r\n        offset: m.index\r\n      });\r\n    }\r\n\r\n    i++;\r\n  }\r\n\r\n  path += strict ? '' : path[path.length - 1] === '/' ? '?' : '/?';\r\n\r\n  // If the path is non-ending, match until the end or a slash.\r\n  if (end) {\r\n    path += '$';\r\n  } else if (path[path.length - 1] !== '/') {\r\n    path += lookahead ? '(?=/|$)' : '(?:/|$)';\r\n  }\r\n\r\n  return new RegExp('^' + path, flags);\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}